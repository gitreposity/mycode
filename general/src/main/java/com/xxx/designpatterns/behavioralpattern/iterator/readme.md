## 迭代器模式
- Why 我们在不知道集合底层数据结构的时候，可以使用迭代器无脑的去遍历
- Good 封装性好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心
- Bad  对于比较简单的遍历（数组或者有序列表），使用迭代器方式遍历较为繁琐而且遍历效率不高，使用迭代器的方式比较适合那些底层以链表形式实现的集合
- Define
    - 提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节
    - 关键角色
        1. 迭代器角色(负责定义访问和遍历元素的接口,如Iterator接口)
        2. 具体迭代器角色(实现迭代器接口，并要记录遍历中的当前位置,如ArrayList中的内部类)
        3. 容器角色(提供创建迭代器的接口，如List,Set)
        4. 具体容器角色(实现创建具体迭代器角色的接口，这个具体迭代器角色与该容器的结构相关,如ArrayList)
- UsingScenes
- 迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。
    假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。
  但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，
  并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，
  我们只需要使用语言中已有的容器和迭代器就可以了。
- expand 
  Q. 为什么Colletion不是直接继承Iterator，而是通过继承Iterable？
- Link 
    - https://blog.csdn.net/zhengzhb/article/details/7610745?utm_source=blogxgwz7
    - https://www.cnblogs.com/xrq730/p/4907184.html